#!/usr/bin/python3
# IOI submission tool
# (c) 2024-2025 Martin Mare≈° <mj@ucw.cz>

import argparse
from dataclasses import dataclass
from datetime import datetime
import hashlib
import logging
import logging.handlers
import os
import re
import requests
import sys
from typing import Tuple, NoReturn
from zipfile import ZipFile


CMS_URL = 'http://localhost:8888'
LOCAL_STORAGE = '/tmp/submissions'
LANGUAGE_EXTENSIONS = {'cpp'}


@dataclass
class SubmittedFile:
    ident: str          # File identifier in CMS (e.g., "task.%l" or "output3.txt")
    cms_name: str       # File name in CMS (e.g., "taks.cpp" or "output3.txt")
    local_name: str     # Local name of the submitted file (including path)


@dataclass
class Submission:
    task: str
    key: str
    local_path: str
    files: list[SubmittedFile]
    hash: str = ""


def die(msg: str) -> NoReturn:
    print(msg, file=sys.stderr)
    sys.exit(1)


class LoginError(RuntimeError):
    pass


def cms_login() -> str:
    login_url = f'{CMS_URL}/api/login'

    try:
        r = requests.post(login_url, timeout=5)
    except requests.exceptions.Timeout:
        raise LoginError('Timed out')
    except requests.exceptions.ConnectionError:
        raise LoginError('Connection error')

    try:
        js = r.json()
    except requests.exceptions.JSONDecodeError:
        raise LoginError(f'Server gave non-JSON reply with status {r.status_code}')

    if r.status_code != 200:
        raise LoginError(js.get('error', 'Unknown error'))

    return js['login_data']



def cms_submit(sub: Submission) -> Tuple[int, str]:
    try:
        auth_token = cms_login()
    except LoginError as err:
        return (0, f'Login failed: {err}')

    submit_url = f'{CMS_URL}/api/{sub.task}/submit'
    files = {sf.ident: (sf.cms_name, open(sf.local_name, 'rb')) for sf in sub.files}

    try:
        r = requests.post(submit_url, files=files, headers={'X-CMS-Authorization': auth_token}, timeout=5)
    except requests.exceptions.Timeout:
        return (0, 'Timed out')
    except requests.exceptions.ConnectionError:
        return (0, 'Connection error')

    try:
        js = r.json()
    except requests.exceptions.JSONDecodeError:
        return (0, f'Server gave non-JSON reply with status {r.status_code}')

    if r.status_code != 200:
        err = js.get('error', 'Unknown error')
        if 'details' in js:
            err += ' (' + js['details'] + ')'
        return (-1, err)

    if 'id' in js:
        return (1, 'Submitted')
    else:
        return (0, 'Malformed reply')


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description='Submits an IOI task solution')
    parser.add_argument('task', help='task name')
    parser.add_argument('file', nargs='+', help='file names')
    parser.add_argument('--outputs',
                        help='Output files are submitted in this task. '
                             'This option contains a space-separated list of output file names '
                             'without the suffix ".txt".')
    parser.add_argument('--mixed', default=False, action='store_true',
                        help='Allow submitting a program source in addition to output files.')

    args = parser.parse_args()

    if args.mixed and not args.outputs:
        parser.error('The --mixed option can be used only with --output')

    # This should match cms.db.types.Codename
    if not re.fullmatch(r'[A-Za-z0-9_-]+', args.task):
        parser.error('Task names must be alphanumeric')

    return args


def gather_files(args: argparse.Namespace) -> list[SubmittedFile]:
    sources = []
    outputs = []
    allow_source = args.mixed or not args.outputs
    allow_outputs = bool(args.outputs)

    for file in args.file:
        _, file_base = os.path.split(file)
        prefix, ext = os.path.splitext(file_base)
        if not os.path.exists(file):
            die(f'File "{file}" does not exist')
        if not os.path.isfile(file):
            die(f'"{file}" is not a regular file')
        if len(ext) < 2:
            die(f'File "{file}" has no extension')
        elif ext == '.txt':
            if not allow_outputs:
                die(f'Output files like "{file}" may not be submitted in this task')
            if prefix not in args.outputs:
                die(f'This task does not accept output file "{file}"')
            if any(file_base == f.ident for f in outputs):
                die(f'Output file "{file_base}" may not be submitted multiple times at once')
            outputs.append(SubmittedFile(file_base, file_base, file))
        elif ext[1:] in LANGUAGE_EXTENSIONS:
            if not allow_source:
                die(f'Program source files like "{file}" may not be submitted in this task')
            if sources:
                die('Only a single source file may be submitted')
            sources.append(SubmittedFile(args.task + '.%l', args.task + ext, file))
        else:
            die(f'File "{file}" has an unrecognized extension "{ext}"')

    return sources + outputs


def make_submission(args: argparse.Namespace) -> Submission:
    when = datetime.now().strftime('%Y%m%d-%H%M%S-%f')
    key = f'{when}:{args.task}'

    return Submission(
        task=args.task,
        key=key,
        local_path=LOCAL_STORAGE + '/' + key,
        files=gather_files(args),
    )


def record_locally(sub: Submission) -> None:
    try:
        with ZipFile(sub.local_path, mode='w') as zip:
            for sf in sub.files:
                zip.write(sf.local_name, arcname=sf.cms_name)
    except OSError as e:
        die(f'Error when processing submission: {e}')

    try:
        with open(sub.local_path, 'rb') as local_file:
            os.fsync(local_file.fileno())
            sub.hash = hashlib.file_digest(local_file, 'sha256').hexdigest()
    except OSError as e:
        die(f'Cannot write local submission: {e.strerror}')


def keep_locally(sub: Submission, verdict: str) -> None:
    os.rename(sub.local_path, sub.local_path + '.' + verdict)

    dir_fd = os.open(LOCAL_STORAGE, os.O_RDONLY)
    os.fdatasync(dir_fd)
    os.close(dir_fd)


logger = logging.getLogger('ioisubmit')
logger.setLevel(logging.DEBUG)
handler = logging.handlers.SysLogHandler(address='/dev/log')
handler.ident = 'ioisubmit: '
logger.addHandler(handler)

args = parse_args()
sub = make_submission(args)
print(f'Submitting solution of task {sub.task}')

record_locally(sub)
logger.info(f'Submission <{sub.key}>: Hash {sub.hash}')

cms_ok, cms_msg = cms_submit(sub)
if cms_ok > 0:
    logger.info(f'Submission <{sub.key}>: Submitted to CMS')
    keep_locally(sub, 'cmsok')
    print('Submitted to CMS')
elif cms_ok < 0:
    logger.info(f'Submission <{sub.key}>: Rejected by CMS: {cms_msg}')
    keep_locally(sub, 'cmsrej')
    die(cms_msg)
else:
    logger.info(f'Submission <{sub.key}>: Recording locally, CMS said: {cms_msg}')
    keep_locally(sub, 'local')
    print('CMS failed, submission recorded locally')
